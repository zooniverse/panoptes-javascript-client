// Generated by CoffeeScript 2.7.0
(function() {
  var DEFAULT_SIGNAL, Emitter, arraysMatch, callHandler,
    splice = [].splice;

  DEFAULT_SIGNAL = 'change';

  arraysMatch = function(array1, array2) {
    var i, item, matches, ref;
    matches = (function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = array1.length; j < len; i = ++j) {
        item = array1[i];
        if (array2[i] === item) {
          results.push(i);
        }
      }
      return results;
    })();
    return (array1.length === (ref = array2.length) && ref === matches.length);
  };

  callHandler = function(handler, payload) {
    var boundArgs, context;
    // Handlers can be in the form [context, function or method name, bound arguments...]
    if (Array.isArray(handler)) {
      [context, handler, ...boundArgs] = handler;
      if (typeof handler === 'string') {
        handler = context[handler];
      }
    } else {
      boundArgs = [];
    }
    handler.apply(context, boundArgs.concat(payload));
  };

  module.exports = Emitter = (function() {
    class Emitter {
      constructor() {
        this._callbacks = {};
      }

      listen(...arg) {
        var base, callback, ref, signal;
        ref = arg, [...arg] = ref, [callback] = splice.call(arg, -1);
        [signal] = arg;
        if (signal == null) {
          signal = DEFAULT_SIGNAL;
        }
        if ((base = this._callbacks)[signal] == null) {
          base[signal] = [];
        }
        this._callbacks[signal].push(callback);
        return this;
      }

      stopListening(...arg) {
        var callback, handler, i, index, j, ref, ref1, signal;
        ref = arg, [...arg] = ref, [callback] = splice.call(arg, -1);
        [signal] = arg;
        if (signal == null) {
          signal = DEFAULT_SIGNAL;
        }
        if (this._callbacks[signal] != null) {
          if (callback != null) {
            if (Array.isArray(callback)) {
              // Array-style callbacks need not be the exact same object.
              index = -1;
              ref1 = this._callbacks[signal];
              for (i = j = ref1.length - 1; j >= 0; i = j += -1) {
                handler = ref1[i];
                if (Array.isArray(handler)) {
                  if (arraysMatch(callback, handler)) {
                    index = i;
                    break;
                  }
                }
              }
            } else {
              index = this._callbacks[signal].lastIndexOf(callback);
            }
            if (index !== -1) {
              this._callbacks[signal].splice(index, 1);
            }
          } else {
            this._callbacks[signal].splice(0);
          }
        }
        return this;
      }

      emit(signal, ...payload) {
        var callback, j, len, ref;
        if (signal == null) {
          signal = DEFAULT_SIGNAL;
        }
        if (signal in this._callbacks) {
          ref = this._callbacks[signal];
          for (j = 0, len = ref.length; j < len; j++) {
            callback = ref[j];
            callHandler(callback, payload);
          }
        }
        return this;
      }

      destroy() {
        var callback, j, len, ref, signal;
        this.emit('destroy');
        for (signal in this._callbacks) {
          ref = this._callbacks[signal];
          for (j = 0, len = ref.length; j < len; j++) {
            callback = ref[j];
            this.stopListening(signal, callback);
          }
        }
      }

    };

    Emitter.prototype._callbacks = null;

    return Emitter;

  }).call(this);

}).call(this);
