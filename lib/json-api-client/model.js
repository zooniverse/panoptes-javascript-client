// Generated by CoffeeScript 2.7.0
(function() {
  var Emitter, Model, isIndex, mergeInto, removeUnderscoredKeys,
    indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;

  Emitter = require('./emitter');

  mergeInto = require('./merge-into');

  isIndex = function(string) {
    var integer;
    integer = parseInt(string, 10);
    return integer.toString(10) === string && !isNaN(integer);
  };

  removeUnderscoredKeys = function(target) {
    var i, key, len, results, results1, value;
    if (Array.isArray(target)) {
      results1 = [];
      for (i = 0, len = target.length; i < len; i++) {
        value = target[i];
        results1.push(removeUnderscoredKeys(value));
      }
      return results1;
    } else if ((target != null) && typeof target === 'object') {
      results = {};
      for (key in target) {
        value = target[key];
        if (key.charAt(0) !== '_') {
          results[key] = removeUnderscoredKeys(value);
        }
      }
      return results;
    } else {
      return target;
    }
  };

  module.exports = Model = (function() {
    class Model extends Emitter {
      constructor(...configs) {
        super(...configs);
        this._changedKeys = [];
        mergeInto(this, ...configs);
        this.emit('create');
      }

      update(changeSet = {}) {
        var base, i, key, lastKey, len, name, path, rootKey, value;
        if (typeof changeSet === 'string') {
          for (i = 0, len = arguments.length; i < len; i++) {
            key = arguments[i];
            if (indexOf.call(this._changedKeys, key) < 0) {
              this._changedKeys.push(...arguments);
            }
          }
        } else {
          for (key in changeSet) {
            if (!hasProp.call(changeSet, key)) continue;
            value = changeSet[key];
            path = key.split('.');
            rootKey = path[0];
            base = this;
            while (path.length !== 1) {
              if (base[name = path[0]] == null) {
                base[name] = isIndex(path[1]) ? [] : {};
              }
              base = base[path.shift()];
            }
            lastKey = path.shift();
            if (value === void 0) {
              if (Array.isArray(base)) {
                base.splice(lastKey, 1);
              } else {
                delete base[lastKey];
              }
            } else {
              base[lastKey] = value;
            }
            if (indexOf.call(this._changedKeys, rootKey) < 0) {
              this._changedKeys.push(rootKey);
            }
          }
        }
        this.emit('change');
        return this;
      }

      hasUnsavedChanges() {
        return this._changedKeys.length !== 0;
      }

      toJSON() {
        return removeUnderscoredKeys(this);
      }

      destroy() {
        this._changedKeys.splice(0);
        return super.destroy();
      }

    };

    Model.prototype._changedKeys = null;

    return Model;

  }).call(this);

}).call(this);
